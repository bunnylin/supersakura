User Interactions
=================

In general:
- Reading text: enter/click/confirm to continue.
- Textbox choice selection: highlight choice and enter/click/confirm.
- Imagemap choice selection: point & click, or highlight and enter/confirm.
- Mouseover such imagemap areas, or move between them with cursors.
- Skip animations etc by triggering minor or major interrupt events.
- Meta-interaction through modal pop-up menu, and summonable special menus.

Below, input reactions are tested from the highest downward. As soon as any
reaction is triggered, the remaining items need not be checked.

Keyboard
--------
Enter
- If skip seen text mode is enabled, disable it.
- If textboxes are hidden, make them visible.
- If box 0 is in showtext state and transcript mode is off, retrieve the
  last line, and if it's not empty, compile and run it as a minifiber.
- If a mouseoverable without -mouseonly is highlighted and it has a trigger
  label, trigger it.
- If choicematic is active, select the highlighted choice.
- If a pageable box needs to show more content, scroll the box.
- If choicematic typeinbox is valid, and any fibers are in waittyping state,
  resume the fibers.
- If any fibers are waiting for a keypress, resume the fibers.
- If a normal interrupt is defined, trigger it.

Esc
- If skip seen text mode is enabled, disable it.
- If textboxes are hidden, ignore.
- If box 0 is in showtext state and transcript mode is on, disable transcript
  mode and popout the box.
- If choicematic is active, and not on top choice level, go up a level.
- If an esc-interrupt is defined, trigger it.
- If metastate is normal, enter the metamenu metastate.

Normal text input
- If textboxes are hidden, ignore.
- If box 0 is in showtext state and transcript mode is off, print the
  character in the box.
- If choicematic is set to accept typing in a box, print the character there.
- If choicematic is active, then scan from current highlight onward to the
  first choice beginning with the entered character, and highlight that. Roll
  around the choice showlist as needed.

Cursor keys left/right
- If box 0 is in showtext state and transcript mode is off, move the caret?
- If choicematic is active and has more than one column, move the highlight.
- If mouseoverables without -mouseonly exist, find the closest left/right
  from current mousexy and mouseon it, mouseoffing current overable if any.

Cursor keys up/down
- If choicematic is active, move the highlight.
- If a freely scrollable box exists, scroll the box up/down.
- If mouseoverables without -mouseonly exist, find the closest up/down from
  current mousexy and mouseon it, mouseoffing current overable if any.

Home/end/pageup/pagedown
- If pressed home/end, and box 0 is in showtext state and transcript mode is
  off, move the caret?
- If choicematic is active, move the highlight.
- If a freely scrollable box exists, scroll the box.

Ctrl-A
- Enable/disable skip seen text mode.

Ctrl-B
- Hide/display textboxes, if boxes are currently hidable.

Ctrl-D
- If debug mode is not enabled, ignore. (Ctrl-XYZZY to enable debug mode.)
- If boxes hidden, show boxes, and don't stop at this step.
- If box 0 is in showtext state and transcript mode is off, pop out the box.
- Otherwise disable transcript mode and pop in the box.

Ctrl-L
- If not in normal metastate, ignore.
- Otherwise enter saveload metastate, with load highlighted.

Pause, Ctrl-P
- Pause/unpause the game.

Shift-Pause, Ctrl-Shift-P, Ctrl-Alt-P
- Enter single-step mode.

Ctrl-Q
- If not in normal metastate, ignore.
- Otherwise enter quit confirm metastate.

Ctrl-S
- If not in normal metastate, ignore.
- Otherwise enter saveload metastate, with save highlighted.

Ctrl-T
- If not in normal metastate or boxes hidden, ignore.
- If box 0 is in showtext state and transcript mode is on, disable transcript
  mode and pop out the box.
- Otherwise enable transcript mode and pop in the box.

Gamepad (tbd)
-------

- Start button: pause and unpause the game
- If textboxes are hidden, then confirm/hide/cancel button makes them visible
- If textboxes are visible and any boxes are displayed, then hide button
  hides the textboxes
- If the topmost interactive box has choices
   + Direction buttons and left stick change selection in box
   + Confirm button selects current selection in box like Enter
   + Cancel button cancels toward the box's top choice level, or if already
     on the top level, then pass the cancel button to the next check
- If the topmost interactive box has no choices
   + Direction buttons and left stick are passed to the next check
   + Confirm button works like Enter
   + Cancel button is passed to the next check
- If mouseoverables are defined
   + Direction buttons and left stick move highlight between mouseover areas
   + Confirm button selects the currently highlighted area; if none is
     highlighted, pass it to the next check
   + Cancel button is passed to the next check
- If mouseoverables are not defined either...
   + Direction buttons and left stick are ignored
   + Confirm/cancel button: if interrupt is defined, invokes it
   + Menu button:
      * if esc-interrupt is defined, invokes it
      * else summons the metamenu

  it's bad to have mousables during a choicebox since it won't be
  accessible through the keyboard or gamepad

Mouse (tbd)
-----

- Mouse movement:
   + If textboxes are visible and the topmost interactive box has choices,
     and the mouse is over a choice, then highlight it
   + Also, if mouseoverables are defined, and the mouse is no longer over one
     or more, then trigger mouseoff events; if it is over new mouseoverables,
     then trigger mouseon events
- Left-click:
   + If textboxes are hidden, then make them visible
   + Else if the topmost interactive box has choices, and the mouse is over
     a choice, then select the choice
   + Else if the topmost interactive box has no choices, and the mouse is
     over the box, then do the same as Enter
   + Else if mouseoverables are defined, and the mouse is currently on one or
     more, then trigger them
   + Else if the topmost interactive box has no choices, then do the same
     as Enter
   + Else if interrupt is defined, invokes it
- Right-click:
   + If textboxes are visible and the topmost interactive box has choices
     and it's not already on the top choice level, then cancels toward the
     box's top choice level
   + Else if textboxes are visible and the mouse is over any displayed box,
     then hides the textboxes
   + Else if esc-interrupt is defined, invokes it
   + Else summons the metamenu
- Mouse wheel?


States (tbd)
======

Pausestate
0 PAUSESTATE_NORMAL: unpaused
1 PAUSESTATE_SINGLE: single-stepping
2 PAUSESTATE_PAUSED: paused

Locstate
0 LOCSTATE_NORMAL: not in special screen, metamenu etc can be summoned
1 LOCSTATE_SPECIAL: in a special screen

Fiberstate
0 FIBERSTATE_NORMAL: executing script code
1 FIBERSTATE_WAITBOX: waiting until the box being waited for no longer has
  the interactiveness flag set; or -1 for all boxes
2 FIBERSTATE_WAITSLEEP: waiting for all sleep fx to end
3 FIBERSTATE_WAITFX: waiting for all timed fx to end

PAUSE: User may pause/unpause at any time by pressing the pause button
- Change window title to say "paused", otherwise no visual effect
- While paused, override tickcount with 0 all the time
- No events are triggered, timers or mouseovers or anything
- Renderer is not called (or if must be, then with tickcount 0)
- The metamenu cannot be summoned

SINGLE-STEP: Pressing shift-pause
- Unpauses the game and sets it to single-step mode instead
- Runs a single script command, then a single round of mouseovers etc and the
  renderer, overriding the tickcount with resttime. During the user input
  processing it would need to specifically check if a mouse button is being
  held down, and if so, treat that as a click issued during the single step.
- At the end of the main loop the game is re-paused

METAMENU: User may summon the metamenu by pressing ESC or right-clicking
- This works at any time except if the game is PAUSED or a METAMENU exists.
- Jump to the metamenu script, which must push the current textbox state, and
  sets up its own box
- Renderer keeps being called, tickcount is not overridden
- Events are not triggered, timers or mouseovers or anything


Metamenu (tbd)
========

While the METAMENU has been invoked:
- On entry:
   + If textboxes are hidden, they are made visible
   + Script fibers and events are pushed and cleared
   + The existing animations, boxes, and effects are pushed and frozen
   + The pushed stuff all together forms an instant save state
   + Spawn a METAMENU script fiber
- On exit:
   + Pop everything from the instant save state
- Script fibers, events, animations, effects run normally
- Textboxes cannot be hidden

- Cursor keys and enter works as normal, ESC dismisses the metamenu,
  other keyboard shortcuts do nothing
- Gamepad direction buttons change selection, select button selects current
  selection, cancel and start buttons dismiss the metamenu as above
- Mouseovers on box change selections, left-click on selection selects it,
  left-click anywhere outside the box or right-click anywhere dismisses the
  metamenu as above

- Metamenu may call saveload and settings scripts

Save (Ctrl-S)
Load (Ctrl-L)
Transcript (Ctrl-T)
Skip seen messages (Ctrl-A)
Fullscreen (Alt-Enter)
Viewframe (Ctrl-F)
- - - - - - - -
Settings
Return to title
Quit (Ctrl-Q)

Save:
Right-click menu, ctrl-S, runscript SAVELOAD
All have the same effect, running script SAVELOAD.
Disabled entirely when within the SAVELOAD script.

Load:
Right-click menu, ctrl-L, runscript SAVELOAD
All have the same effect, running script SAVELOAD.
Disabled entirely when within the SAVELOAD script.

Transcript:
Right-click menu, ctrl-T

Debug console:
Ctrl-D only.

Skip seen messages:
Right-click menu, ctrl-A
Disabled when within SAVELOAD or mainscript. Automatically turned off upon
a left-click, right-click, esc, enter, entering game states 2..4, or upon
printing an unseen message.

Fullscreen:
Right-click menu, alt-enter
Menu has a tick next to option if in fullscreen mode.

Viewframe:
Right-click menu
Menu has a tick next to option if in viewframe mode.
Removed from menu if frame stuff hasn't been fully defined.

Settings:
Right-click menu
Opens a modal settings dialog, freezing the game until dialog closes.

Return to title:
Right-click menu
Confirm returning to title.
Disabled if in mainscript.

Quit:
Right-click menu, ctrl-Q, alt-F4, close window button, sys.quit command
Confirm quitting, unless in mainscript or sys.quit issued

Mouse functionality:
In case mouseover areas have been defined, moving the mouse on or off such
areas will generate mouseover events for the script.

Left-clicking a defined mouseover area generates a mouseover clicked event.
Left-clicking while textboxes have been temporarily removed will bring them
back in. Otherwise, left-clicking while an interrupt callback has been
defined will generate an interrupt event. Left-clicking while waiting for an
anykeypress clears the waitkey. If choices are up, left-clicking on a choice
selects it.
Otherwise a left-click does nothing.

Right-click and ESC are equivalent. Right-clicking while an interrupt
callback has been defined will generate an interrupt event. If a verb has
been selected and subjects are up, right-clicking anywhere or pressing ESC
cancels the selection and goes back to verb choices. Right-clicking on the
area of textbox 1 while the textbox's style has a non-void background will
make all textboxes temporarily pop out. Right-clicking anywhere while
textboxes have been temporarily removed will bring them back in.
Otherwise, a right-click will spawn the popup menu.


Settings menu reqs
==================

Because I'd like to allow gamepad controls, the settings menu like other
menus needs to be implemented in-engine. Making it work like PPSSPP's menus
seems reasonable: a freely scrollable list of items on the left and their
current values on the right, consisting of checkboxes, comboboxes, and
possibly numeric values. Pressing enter/select checks or unchecks a box,
brings up a new listbox for a multiple choice, or a slider for number
selection. Cursor keys move up and down the list, esc/cancel exits.

The list is not scrollable by mouseover alone. Mouse wheel scrolls the list.
Left-click on an item selects it, right-click cancels backward but won't
exit the menu. Topmost menu item should be Exit Settings.

If there are a lot of menu options, split the menu into submenus from a main
menu, where the main menu is a separate screen; having two menus visible
simultaneously for the user to hop between isn't workable with the current
textbox design.

Window size probably doesn't need to be editable graphically. The auto option
is good enough for most cases, and otherwise the user can edit the ini file.
Trying to set a window pixel size would be a bit annoying in a gamepad-driven
menu, due to the large number ranges involved. Fullscreen mode is also always
at the native resolution now, so no settings required for it.

Settings that won't be needed: protag name change (not supported by all games
anyway, and it's game-specific, and would require a virtual keyboard),
autosave settings (defaults should be sufficient), censorship level (it's
game-specific, easiest done upon newgame if at all)

Settings that need to included:

UI size multiplier - when selected, brings up a slider? Defaults to current
size multiplier. Value should be displayed as a percentage, and since its
useful values are exponential? logarithmic?, it may be best to do something
like an x*x function from the slider's linear value and scale it to
a reasonable minimum and maximum bounds, where 32k is 100%.

Pixel scaler - combobox.

Font selection - 2 comboboxes, for Latin and Japanese; when selected, brings
up a list of enumerated font face names, default-highlighting the currently
selected font.

Sound - checkbox.

Sound volume - slider.

Interface sounds - checkbox.

(I don't see a need for a separate music/effects setting. You get both or
neither. Also, voiceovers don't exist.)


Textboxes, originally
=====================

Most games in framed mode have a box of 512x64. 16px font, no linespacing.
Twilight has 496x64. It has a 16px font, with no linespacing.
Marilyn has 500x100.
Mayclub is 600x80. It has a 16px font, with 4 pixels extra linespacing.
Nocturne is 512x80. It has a 16px font, with 4 pixels extra linespacing.
Eve is 416x57. It has a 16px font, with 3 pixels extra linespacing.
Angelscollection 2 has 544x64.
Angelscollection 1 has 592x48. (add a decomp hack to extend height to 64?)

Sakura has viewarea at 80,16; size 480x296. Textbox at 64,328; size 512x64.
Viewarea 8192,2621; size 49152x48497. Textbox 6554,53740; size 52429x10486.


Saving and loading (ideas)
==================

- Both on same screen, 10 slot buttons, save button and load button
- Allow only when gamestate is waiting for keypress or user choices
- sys.allowsaves/allownosaves
- While on saveload screen, make sure effector suspends all effects except
  transitions, and make right-click/esc quit the screen
- Push fxbuffyrefcount, set to 0
- RunScript SAVELOAD
   + gfx.pushgobstate : Push current gob state somewhere safe
   + gfx.stopanims
   + gfx.screenshotbkg : Clear textboxes from the screen, copy the contents
     of outputbuffy^ into a new gcache item, attach it to background gob 0
   + gfx.darkenbkg : Alter every pixel of the background gob to be the
     average of its color and its greyscale value shr 1
   + gfx.clearallbutbkg
   + draw all saveload screen elements as gobs, set up mouseover events
   + gfx.transition crossfade
   + @exitsaveload: gfx.popgobstate
   + gfx.transition crossfade

- When a game is loaded, if the current script is SAVELOAD, then the script
  is automatically popped off and execution continues in the script from
  where SAVELOAD was called
- Also upon loading all events whose owner was the SAVELOAD script will be
  wiped out, so the saving interface mouseovers and such won't haunt us
